"""
https://contest.yandex.ru/contest/45468/problems/27/


27. Вывести маршрут максимальной стоимости
Ограничение времени	1 секунда
Ограничение памяти	256Mb
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
В левом верхнем углу прямоугольной таблицы размером N×M находится черепашка. В каждой клетке таблицы записано
некоторое  число. Черепашка может перемещаться вправо или вниз, при этом маршрут черепашки заканчивается в правом
нижнем  углу таблицы.
Подсчитаем сумму чисел, записанных в клетках, через которую проползла черепашка (включая начальную и конечную
клетку).  Найдите наибольшее возможное значение этой суммы и маршрут, на котором достигается эта сумма.

Формат ввода
В первой строке входных данных записаны два натуральных числа N и M, не превосходящих 100 — размеры таблицы. Далее
идет  N строк, каждая из которых содержит M чисел, разделенных пробелами — описание таблицы. Все числа в клетках
таблицы  целые и могут принимать значения от 0 до 100.
Формат вывода
Первая строка выходных данных содержит максимальную возможную сумму, вторая — маршрут, на котором достигается эта
сумма . Маршрут выводится в виде последовательности, которая должна содержать N-1 букву D, означающую передвижение
вниз  и M-1 букву R, означающую передвижение направо. Если таких последовательностей несколько, необходимо вывести
ровно  одну (любую) из них.
Пример
Ввод	Вывод
5 5
9 9 9 9 9
3 0 0 0 0
9 9 9 9 9
6 6 6 6 8
9 9 9 9 9
74
D D R R R R D D
"""


def get_max_cost_path(matrix, n, m):
    dp = [[0] * (m + 1) for _ in range(n + 1)]
    p = [['0'] * (m + 1) for _ in range(n + 1)]

    for i in range(1, n + 1):
        for j in range(1, m + 1):
            if dp[i - 1][j] > dp[i][j - 1]:
                mx = dp[i - 1][j]
                p[i][j] = 'D'
            elif dp[i - 1][j] < dp[i][j - 1]:
                mx = dp[i][j - 1]
                p[i][j] = 'R'
            else:
                p[i][j] = 'D'
                mx = dp[i - 1][j]
                if i + 1 > n:
                    p[i][j] = 'R'
                if j + 1 > m:
                    p[i][j] = 'D'
            dp[i][j] = mx + matrix[i - 1][j - 1]

    path = []
    i, j = n, m
    while not((i == 1) and (j == 1)):
        path.append(p[i][j])
        if p[i][j] == 'D':
            i -= 1
        else:
            j -= 1
    return dp[n][m], path[::-1]


n, m = map(int, input().split())
matrix = tuple((tuple(map(int, input().split())) for _ in range(n)))

ans, path = get_max_cost_path(matrix, n, m)
print(ans)
print(*path)
